"""
Methods to handle linear constraints.

In particular, implements a simple version of the double description method [1] to get the generators
of the nearby tangent cone

[1] K. Fukuda and A. Prodon. Double description method revisited.
    In: Combinatorics and Computer Science (M. Deza, R. Euler, I. Manoussakis eds), Springer 1996
"""
import numpy as np
from scipy.linalg import null_space


def nearby_constraints(A, b, x, alpha):
    """
    For constraint set {y : A @ y <= b}, determine the nearly active constraints J(x,alpha)

    Returns a list, subset of [1, ..., m] of nearly active constraints (m = total number of constraints)
    """
    m, n = A.shape  # number of constraints, dimension
    assert b.shape == (m,), "A and b have incompatible dimensions"
    assert x.shape == (n,), "A and x have incompatible dimensions"
    assert alpha > 0.0, "alpha must be strictly positive"
    assert np.all(A @ x <= b), "x must be feasible, Ax<=b"
    s = b - A @ x  # all >= 0
    J = []
    for j in range(m):
        aj = A[j, :]
        if s[j] <= alpha * np.dot(aj, aj):
            J.append(j)
    return J


def full_rank_generators(A):
    """
    Matrix A is n*m with m <= n, and A has full (column) rank

    Given the cone generated by columns of A, return a set of generators for the corresponding polar cone

    The generators are the columns of the returned matrix
    """
    n, m = A.shape
    assert m <= n, "A must be size n*m with m <= n"
    if m == 0:
        # cone is {0}, so polar cone is all of R^n --> take any PSS for R^n as a valid set of generators
        return np.hstack((np.eye(n), -np.eye(n)))
    assert np.linalg.matrix_rank(A) == m, "A must be full rank"
    Apinv = np.linalg.pinv(A.T)
    # print("-Apinv =")
    # print(-Apinv)
    if m < n:
        null = null_space(A.T)
        # print("null =")
        # print(null)
        return np.hstack((-Apinv, null, -null))
    else:
        return -Apinv


def simplex_example():
    # Simplex example
    m = 3
    n = 2
    A = np.array([[-1.0, 0.0], [0.0, -1.0], [1.0, 1.0]])
    b = np.array([0.0, 0.0, 1])
    # j = 0  <-->  -e1^T x <= 0  (i.e. x1 >= 0)
    # j = 1  <--> -e2^T x <= 0 (i.e. x2 >= 0)
    # j = 2  <--> e^T x <= 1  (i.e. x1+x2 <= 1)
    # x = np.array([0.02, 0.96])
    # x = np.array([0.5, 0.5])
    # x = np.array([0.05, 0.05])
    x = np.array([0.2, 0.2])
    alpha = 0.1
    J = nearby_constraints(A, b, x, alpha)  # expect [0, 2]
    N = A[J, :].T  # columns are generators of normal cone
    print("nearby cons = ", J)
    print("N generators =")
    print(N)
    T = full_rank_generators(N)  # columns are generators of tangent cone
    T = T * alpha / np.linalg.norm(T, axis=0)  # scale so columns all have length alpha
    print("T generators =")
    print(T)
    print("poll points (alpha = %g)" % alpha)
    print("x =", x)
    for i in range(T.shape[1]):
        print("x + di =", x + T[:, i])
    return


def main():
    simplex_example()
    print("Done")
    return


if __name__ == '__main__':
    main()
